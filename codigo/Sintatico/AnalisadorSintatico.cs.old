using System;
using System.Collections.Generic;
using System.Linq;
using Lexico;
using AST;

namespace Sintatico
{
    /// <summary>
    /// Analisador Sintático para Portugol Studio
    /// Realiza análise descendente recursiva e construção da AST
    /// </summary>
    public class AnalisadorSintatico
    {
        private List<Token> tokens;
        private int pos = 0;
        private Token atual;

        public AnalisadorSintatico(List<Token> tokens)
        {
            this.tokens = tokens;
            this.atual = tokens[0];
        }

        private void Avancar()
        {
            if (pos < tokens.Count - 1)
            {
                pos++;
                atual = tokens[pos];
            }
        }

        private void Esperar(TipoToken tipo)
        {
            if (atual.Tipo != tipo)
            {
                throw new Exception($"Esperado {tipo}, mas encontrado {atual.Tipo} em [{atual.Linha},{atual.Coluna}]: '{atual.Lexema}'");
            }
            Avancar();
        }

        private bool EhTipo()
        {
            return atual.Tipo == TipoToken.TIPO_INTEIRO ||
                   atual.Tipo == TipoToken.TIPO_REAL ||
                   atual.Tipo == TipoToken.TIPO_LOGICO ||
                   (atual.Tipo == TipoToken.IDENT && atual.Lexema.Equals("cadeia", StringComparison.OrdinalIgnoreCase));
        }

        private string ObterTipo()
        {
            if (atual.Tipo == TipoToken.TIPO_INTEIRO)
            {
                Avancar();
                return "inteiro";
            }
            if (atual.Tipo == TipoToken.TIPO_REAL)
            {
                Avancar();
                return "real";
            }
            if (atual.Tipo == TipoToken.TIPO_LOGICO)
            {
                Avancar();
                return "logico";
            }
            if (atual.Tipo == TipoToken.IDENT && atual.Lexema.Equals("cadeia", StringComparison.OrdinalIgnoreCase))
            {
                Avancar();
                return "cadeia";
            }
            throw new Exception($"Tipo de dados esperado em [{atual.Linha},{atual.Coluna}]");
        }

        /// <summary>
        /// programa := 'programa' '{' (declaracao_var | funcao)* '}'
        /// </summary>
        public NoBloco Analisar()
        {
            if (atual.Tipo != TipoToken.PALAVRA_RESERVADA || !atual.Lexema.Equals("programa", StringComparison.OrdinalIgnoreCase))
            {
                throw new Exception("Programa deve começar com 'programa'");
            }
            Avancar();
            Esperar(TipoToken.CHAVE_ESQ);

            var declaracoes = new List<No>();

            // Processa declarações de variáveis globais e funções
            while (atual.Tipo != TipoToken.CHAVE_DIR && atual.Tipo != TipoToken.EOF)
            {
                // Variáveis globais
                if (EhTipo())
                {
                    declaracoes.AddRange(ParseDeclaracaoVar());
                }
                // Funções
                else if (atual.Tipo == TipoToken.PALAVRA_RESERVADA && atual.Lexema.Equals("funcao", StringComparison.OrdinalIgnoreCase))
                {
                    declaracoes.Add(ParseFuncao());
                }
                else
                {
                    throw new Exception($"Esperado tipo ou 'funcao' em [{atual.Linha},{atual.Coluna}]");
                }
            }

            Esperar(TipoToken.CHAVE_DIR);
            return new NoBloco(declaracoes);
        }

        private void ParseDeclaracoes()
        {
            while (Verifica("var"))
            {
                Consome("var");
                var nome = Atual().Lexema;
                ConsomeTipo(TipoToken.IDENT);
                Consome(";");
                codigo.AppendLine($"            int {nome} = 0;");
            }
        }

        private void ParseInstrucoes()
        {
            while (!Verifica("fim") && Atual().Tipo != TipoToken.EOF)
            {
                if (Verifica("escreva"))
                    ParseEscreva();
                else if (Verifica("leia"))
                    ParseLeia();
                else if (Verifica("se"))
                    ParseSe();
                else if (Verifica("enquanto"))
                    ParseEnquanto();
                else if (Verifica("funcao"))
                    ParseFuncao();
                else if (Verifica("retorne"))
                    ParseRetorno();
                else if (VerificaTipo(TipoToken.IDENT) && Proximo().Tipo == TipoToken.ATRIBUICAO)
                    ParseAtribuicao();
                else if (VerificaTipo(TipoToken.IDENT) && Proximo().Tipo == TipoToken.PAREN_ESQ)
                    ParseChamadaFuncao();
                else
                    Avancar();
            }
        }

        private void ParseEscreva()
        {
            Consome("escreva");
            Consome("(");

            var expr = ParseExpressao();
            codigo.Append($"            Console.WriteLine({expr}");

            while (Verifica(","))
            {
                Consome(",");
                expr = ParseExpressao();
                codigo.Append($" + \" \" + {expr}");
            }

            codigo.AppendLine(");");
            Consome(")");
            Consome(";");
        }

        private void ParseLeia()
        {
            Consome("leia");
            Consome("(");
            var nome = Atual().Lexema;
            ConsomeTipo(TipoToken.IDENT);
            codigo.AppendLine($"            if (int.TryParse(Console.ReadLine(), out {nome})) {{ }}");
            Consome(")");
            Consome(";");
        }

        private void ParseSe()
        {
            Consome("se");
            var cond = ParseExpressao();
            if (Verifica("entao") || Verifica("então"))
            {
                if (Verifica("entao")) Consome("entao");
                else Consome("então");
            }
            codigo.AppendLine($"            if ({cond})");
            codigo.AppendLine("            {");

            ParseInstrucoesBloco();

            codigo.AppendLine("            }");

            if (Verifica("senao"))
            {
                Consome("senao");
                codigo.AppendLine("            else");
                
                // Verifica se senao é seguido por outro se
                if (Verifica("se"))
                {
                    // Aninhamento de se/else: não adiciona chaves extras
                    ParseSe();
                }
                else
                {
                    codigo.AppendLine("            {");
                    ParseInstrucoesBloco();
                    codigo.AppendLine("            }");
                }
            }
            
            // Só consome fim se não foi consumido por um aninhamento
            if (Verifica("fim"))
                Consome("fim");
        }

        private void ParseEnquanto()
        {
            Consome("enquanto");
            Consome("(");
            var cond = ParseExpressao();
            Consome(")");
            if (Verifica("faca")) Consome("faca");
            
            codigo.AppendLine($"            while ({cond})");
            codigo.AppendLine("            {");
            ParseInstrucoesBloco();
            codigo.AppendLine("            }");
        }

        private void ParseFuncao()
        {
            Consome("funcao");
            var nomeFuncao = Atual().Lexema;
            ConsomeTipo(TipoToken.IDENT);

            Consome("(");
            var parametros = new List<string>();
            if (!Verifica(")"))
            {
                parametros.Add(Atual().Lexema);
                ConsomeTipo(TipoToken.IDENT);
                while (Verifica(","))
                {
                    Consome(",");
                    parametros.Add(Atual().Lexema);
                    ConsomeTipo(TipoToken.IDENT);
                }
            }
            Consome(")");

            var paramsStr = string.Join(", ", parametros.ConvertAll(p => $"int {p}"));
            codigo.AppendLine($"        private static int {nomeFuncao}({paramsStr})");
            codigo.AppendLine("        {");

            Consome("inicio");
            ParseInstrucoesBloco();
            Consome("fim");

            codigo.AppendLine("            return 0;");
            codigo.AppendLine("        }");
        }

        private void ParseRetorno()
        {
            Consome("retorne");
            var expr = ParseExpressao();
            codigo.AppendLine($"            return {expr};");
            Consome(";");
        }

        private void ParseAtribuicao()
        {
            var nome = Atual().Lexema;
            ConsomeTipo(TipoToken.IDENT);
            Consome("=");
            var expr = ParseExpressao();
            codigo.AppendLine($"            {nome} = {expr};");
            Consome(";");
        }

        private void ParseChamadaFuncao()
        {
            var nome = Atual().Lexema;
            ConsomeTipo(TipoToken.IDENT);
            Consome("(");
            var args = new List<string>();
            if (!Verifica(")"))
            {
                args.Add(ParseExpressao());
                while (Verifica(","))
                {
                    Consome(",");
                    args.Add(ParseExpressao());
                }
            }
            Consome(")");
            Consome(";");
            var argsStr = string.Join(", ", args);
            codigo.AppendLine($"            {nome}({argsStr});");
        }

        private void ParseInstrucoesBloco()
        {
            while (!Verifica("fim") && !Verifica("senao") && !Verifica("else") && Atual().Tipo != TipoToken.EOF)
            {
                if (Verifica("escreva"))
                    ParseEscreva();
                else if (Verifica("leia"))
                    ParseLeia();
                else if (Verifica("se"))
                    ParseSe();
                else if (Verifica("enquanto"))
                    ParseEnquanto();
                else if (Verifica("retorne"))
                    ParseRetorno();
                else if (VerificaTipo(TipoToken.IDENT) && Proximo().Tipo == TipoToken.ATRIBUICAO)
                    ParseAtribuicao();
                else if (VerificaTipo(TipoToken.IDENT) && Proximo().Tipo == TipoToken.PAREN_ESQ)
                    ParseChamadaFuncao();
                else
                    Avancar();
            }
        }

        // Precedência de expressões (do menor para o maior)
        private string ParseExpressao()
        {
            return ParseExprLogicaOu();
        }

        private string ParseExprLogicaOu()
        {
            var esq = ParseExprLogicaE();
            while (Verifica("ou") || Verifica("OU"))
            {
                var op = Atual().Lexema;
                Avancar();
                var dir = ParseExprLogicaE();
                esq = $"({esq} || {dir})";
            }
            return esq;
        }

        private string ParseExprLogicaE()
        {
            var esq = ParseExprRelacional();
            while (Verifica("e") || Verifica("E"))
            {
                var op = Atual().Lexema;
                Avancar();
                var dir = ParseExprRelacional();
                esq = $"({esq} && {dir})";
            }
            return esq;
        }

        private string ParseExprRelacional()
        {
            var esq = ParseAritmetica();
            if (Verifica("==") || Verifica("!=") || Verifica("<") || Verifica(">") || Verifica("<=") || Verifica(">="))
            {
                var op = Atual().Lexema;
                Avancar();
                var dir = ParseAritmetica();
                var opCSharp = op switch
                {
                    "==" => "==",
                    "!=" => "!=",
                    "<" => "<",
                    ">" => ">",
                    "<=" => "<=",
                    ">=" => ">=",
                    _ => "=="
                };
                return $"({esq} {opCSharp} {dir})";
            }
            return esq;
        }

        private string ParseAritmetica()
        {
            var esq = ParseTermo();
            while (Verifica("+") || Verifica("-"))
            {
                var op = Atual().Lexema;
                Avancar();
                var dir = ParseTermo();
                esq = $"({esq} {op} {dir})";
            }
            return esq;
        }

        private string ParseTermo()
        {
            var esq = ParseFator();
            while (Verifica("*") || Verifica("/"))
            {
                var op = Atual().Lexema;
                Avancar();
                var dir = ParseFator();
                esq = $"({esq} {op} {dir})";
            }
            return esq;
        }

        private string ParseFator()
        {
            if (Verifica("nao") || Verifica("NÃO") || Verifica("!"))
            {
                Avancar();
                var expr = ParseFator();
                return $"(!{expr})";
            }

            if (Verifica("("))
            {
                Consome("(");
                var expr = ParseExpressao();
                Consome(")");
                return $"({expr})";
            }

            if (VerificaTipo(TipoToken.NUM))
            {
                var num = Atual().Lexema;
                Avancar();
                return num;
            }

            if (VerificaTipo(TipoToken.STRING))
            {
                var str = Atual().Lexema;
                Avancar();
                return str;
            }

            if (VerificaTipo(TipoToken.IDENT))
            {
                var nome = Atual().Lexema;
                Avancar();
                if (Verifica("("))
                {
                    Consome("(");
                    var args = new List<string>();
                    if (!Verifica(")"))
                    {
                        args.Add(ParseExpressao());
                        while (Verifica(","))
                        {
                            Consome(",");
                            args.Add(ParseExpressao());
                        }
                    }
                    Consome(")");
                    var argsStr = string.Join(", ", args);
                    return $"{nome}({argsStr})";
                }
                return nome;
            }

            throw new Exception($"Esperado expressão, encontrado '{Atual().Lexema}' na linha {Atual().Linha}");
        }
    }
}
